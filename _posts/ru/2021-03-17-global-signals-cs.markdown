---
title:  "Глобальные сигналы в C#"
repository: global-signals
preview: /assets/images/posts/2021-03-17-global-signals-cs/signal-preview.gif
date:   2021-03-17 10:00:00 +0300
categories: ru cases
tags: [C#, unity3d]
lang: Ru
layout: post
---

На этот раз я поделюсь с вами своей реализацией взаимодействия между различными частями приложения, посредством передачи и обработки сигналов. Этот довольно простой способ решил для меня проблему передачи данных от одного объекта к другому при использовании мультисцен в **Unity3d**.

## Предыстория
Как было уже сказано выше, при создании приложения в Unity3d, я столкнулся с тем, что необходимо передавать данные от одного объекта к другому. Более того, это осложнялось использованием мултицсен. Мой проект подразумевает создание множества сцен и мне очень не хотелось в ручную заниматься внедрением зависимостей.
Методы наподобие `FindObjectsOfType` тоже мне не подходили, так как они отнимают слишком много ресурсов для поиска объектов. Хотелось максимально упростить передачу данных между объектами сцен без ущерба производительности.

Углубившись в изучение различных архитектурных паттернов, я натолкнулся на **ECS** и решил, что нашел серебряную пулю, которая убъёт всех моих монстров. Перепробовав самые популярные фреймворки в этой области я выбрал [Actors](https://github.com/PixeyeHQ/actors.unity). Его авторы очень дружелюбные ребята, они даже позволили мне внести некоторые изменения касающиеся загрузки сцен из **AssetBundle**. 

Но как это часто бывает с фреймворками, он предоставлял мне огромные возможности, большинство из которых я не собирался использовать внутри своего проекта. В основном я использовал структуру под названием **Signals**. Сам автор охарактеризовал её примерно так: _"она отправляет сообщение буквально в пустоту, и если есть получатель для него, он его получит в любой части приложения"_.  Это с лихвой покрывало весь спектр моих задач по обеспечению взаимодействия между объектами в сценах. Поняв что мне действительно необходимо, я стал экспериментировать с известными мне на тот момент сущностями в C#.

## Проектирование
Структурная схема демонстрирует простейшую схему передачи сигнала от отправителя к получателю:

![Структурная схема]({{site.url}}/assets/images/posts/{{page.date | date: "%Y-%m-%d"}}-{{page.slug}}/structural-diagram.gif)

Получатель подписывается на определённый тип сигнала. Отправитель генерирует сигнал, передаёт в него данные, и отправляет его в "эфир". Получатель ловит это сигнал и извлекает из него данные и обрабатывает их. Получатель может разорвать связь отписавшись от сигнала. Таким образом отправитель и получатель могут ничего не знать друг о друге, а сигнал служит интерфейсом для передачи данных между ними.

## Реализация
Базовый класс для всех сигналов я решил сделать универсальным, параметр типа при этом ограничил его наследниками:
```csharp
public abstract class Signal<T> where T : Signal<T>
{
    public delegate void Hendler(T signal);
    protected static Hendler hendlers;

    public static void Subscribe(Hendler hendlers)
    {
        Signal<T>.hendlers += hendlers;
    }

    public static void Unsubscribe(Hendler hendlers)
    {
        Signal<T>.hendlers -= hendlers;
    }

    protected static Hendler GetUniqueHendlers(Hendler hendlers)
    {
        HashSet<int> hashs = new HashSet<int>();

        foreach (var hendler in hendlers.GetInvocationList())
        {
            var hash = System.String.GetHashCode(
                hendler.Target?.GetHashCode() + "" +
                hendler.Method.DeclaringType + "" +
                hendler.Method.GetBaseDefinition()
                );

            if (hashs.Contains(hash))
            {
                hendlers -= hendler;
            }
            else { hashs.Add(hash); }
        }
        
        return hendlers;
    }

    public class Exception : System.Exception
    {
        public Exception(string message) : base(message) { }
    }
}
```
Внутри него инкапсулируется статическая переменная в виде делегата, который хранит методы принимающие в качестве праметра, объект производный от типа `Signal<T>`. С помощью этой переменной реализуется механизм подписки на сигнал. 
> **Внимание!** _С большой силой приходит большая ответственность:_ так как ссылки на методы хранятся в статической переменной, позаботьтесь о том, чтобы объекты своевременно отписывались от сигнала, иначе сборщик мусора не сможет их удалить и возникнет утечка памяти.

Несмотря на то, что переменная объявлена в базовом классе, для каждого производного класса создаётся свой делегат. Благодаря этому адресат получает только сообщения того типа, на который подписывался. Метод `Subscribe(Hendler hendlers)` служит для добавления делегатов-подписчиков, а `Unsubscribe(Hendler hendlers)` - для их удаления.

### Пример простого сигнала
Для реализации простого сигнала достатоно наследоваться от типа `Signal<T>`, передав в него тип производного класса и добваить метод для отправки этого сигнала к получателям:
```csharp
public class Message : Signal<Message>
{
    private string text;
    public string Text { get => text; }

    private Message(string text)
    {
        this.text = text;
    }

    public static void Send(string text)
    {
        // Calls delegates that accept this type as a parameter
        hendlers?.Invoke(new Message(text));
    }
}
```
В данной реализации сигнал `Message` инкапсулирует в себе строку с текстом, которую он получит при его создании и затем разошлёт получателям.
Для отправки сообщения служит статический метод `Send(string text)`. Всё что от него требуется - создать экземпляр класса `Message` и вызвать подписанные на него делегаты, передав этот объект в качестве параметра. 

### Отправка и получение сигнала
Для отправки приведённого выше сигнала достаточно простой строчки:
```csharp
Message.Send("Hello World!");
```
Но прежде чем получать данный сигнал желательно на него подписаться:
```csharp
Message.Subscribe(Receive);
```
В качестве параметра указываем имя метода-обработчика данного сигнала:
```csharp
private void Receive(Message message)
{
    System.Console.WriteLine(message.Text);
}
```
Не забываем отписаться, как только получение данного сигнала для нас перестанет быть актуальным:
```csharp
Message.Unsubscribe(Receive);
```

### Пример расширенного сигнала
Приведённый выше пример сигнала обладает двумя существенными недостатками:
* Получатель может на него подписаться несколько раз и при отправке сигнала добавленный метод будет вызываться столько раз, сколько он был добавлен.
* В случае если на сигнал никто не подписан, отправитель будет посылать сигнал в пустоту.

Для успешного преодоления этих проблем можно реализовать сигнал следующим образом:
```csharp
public class Error : Signal<Error>
{
    private string text;
    private static HashSet<int> hashs = new HashSet<int>();
    
    public string Text { get => text; }

    public Error(string text)
    {
        this.text = text;
    }

    public new static void Subscribe(Hendler hendlers)
    {
        Signal<Error>.hendlers = GetUniqueHendlers(Signal<Error>.hendlers + hendlers);
    }

    public static void Send(string text)
    {
        try
        {
            hendlers.Invoke(new Error(text));
        }
        catch (System.NullReferenceException e)
        {
            throw new Exception(e.Message);
        }
    }
}
```
В данном примере во время подписки на сигнал, чтобы исключить из делегатов все дубликаты, используется метод `GetUniqueHendlers(Hendler hendlers)`. В качестве параметра мы передаём делегатов, которые уже подписаны на сигнал вместе с новыми делегатами, а на выходе получаем наобор уникальных делегатов. Этот новый делегат мы и сохраняем вместо старого в нашей статической переменной.

Ещё одним нововведением является то, что мы не проверяем делегата на `null` прежде чем осуществить вызов. Вместо этого мы отлавливаем ошибку `NullReferenceException` и в случае её появления кидаем `Signal<T>.Exception` класса, которое мы сможем в дальнейшем обрабоать согласно логике приложения.

### Предобработка сигналов
Если наследоваться от класса производного от `Signal<T>` (например от `Error`), то наполучившийся тип сигнала уже нельзя будет подписаться, но в этом новом классе можно выполнять некую шаблонную предобрабутку отправляемых в нём данных, например добавить префикс:
```csharp
class Warning : Error
{
    private Warning(string text) : base("Warning: " + text) { }
    public new static void Send(string text)
    {
        try
        {
            hendlers.Invoke(new Warning(text));
        }
        catch (System.NullReferenceException e)
        {
            throw new Exception(e.Message);
        }
    }
}
```
При отправке этого сигнала, все подписчики `Error` будут получать сообщения уже c префиксом _Warning_.

## Вместо заключения
Я понимаю что данный способ многим может показаться небезопасным из-за возможной утечки памяти, но даже кухонным ножом, которым большинство из нас нарезает хлеб для бутербродов, можно порезаться)

Чтобы обезопасить себя при использовании сигнлалов, рекоммендую подписывать на них только объекты, действующие до выхода из самой программы, или же срок жизни которых можно точно определить, и в конце него отписаться от сигнала. В случае с объектами в **Unity3d** можно(и нужно) отписаться от сигнала в методе `OnDestroy()` вызываемом при удалении объекта со сцены. В случае со стандартным C# не стоит пытаться отписаться в деструкторе или в методе `Finalize()` так как он вызывается сборщиком мустора только после удаления всех ссылок на объект, а как вы понимаете ссылка на метод объекта будет хранится в статической переменной до завершения программы. 

Я создал отдельный репозиторий с [примерами](https://github.com/{{ site.github.owner_name }}/examples-global-signals) чтобы вы могли их проверить.
Вы также можете использовать глобальные сигналы в своем проекте, добавив [этот репозиторий](https://github.com/{{ site.github.owner_name }}/{{ page.repository }}) как [подмодуль](https://git-scm.com/book/en/v2/Git-Tools-Submodules):

    git submodule add https://github.com/mofrison/global-signals

В любом случае пользоваться таким способом или нет решать вам. Спасибо за внимание :)
